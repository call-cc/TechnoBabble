(define-module (technobabble common)
  #:use-module (ice-9 textual-ports)
  #:use-module (ice-9 receive)
  #:export (slurp-file
            string-split*))

(define (slurp-file filename)
  (call-with-input-file filename
    (lambda (p)
      (get-string-all p))))

(define (string-split* s delimiter . args)
  (if (not (string? s)) (error "string expected" s))
  (if (not (string? delimiter)) (error "string expected" delimiter))
  (let ((slen (string-length s)))
    (receive (grammar limit no-limit start end)
        (if (pair? args)
            (if (pair? (cdr args))
                (if (pair? (cddr args))
                    (if (pair? (cdddr args))
                        (values (car args) (cadr args) #f (caddr args) (cadddr args))
                        (values (car args) (cadr args) #f (caddr args) slen))
                    (values (car args) (cadr args) #f 0 slen))
                (values (car args) #f #t 0 slen))
            (values 'infix #f #t 0 slen))
      (if (not (memq grammar '(infix strict-infix prefix suffix)))
          (error "grammar must be one of (infix strict-infix prefix suffix)" grammar))
      (if (not limit) (set! no-limit #t))
      (if (not (or no-limit
                   (and (integer? limit) (exact? limit) (>= limit 0))))
          (error "limit must be exact nonnegative integer or #f" limit))
      (if (not (and (integer? start) (exact? start)))
          (error "start argument must be exact integer" start))
      (if (not (<= 0 start slen))
          (error "start argument out of range" start))
      (if (not (<= 0 end slen))
          (error "end argument out of range" end))
      (if (not (<= start end))
          (error "start argument is greater than end argument" (list start end)))

      (cond ((= start end)
             (if (eq? grammar 'strict-infix)
                 (error "empty string cannot be spilt with strict-infix grammar")
                 '()))
            ((string-null? delimiter)
             (%string-split-chars s start end limit))
            (else (%string-split s start end delimiter grammar limit))))))

(define (%string-split-chars s start end limit)
  (if (not limit)
    (map string (string->list s start end))
    (let loop ((r '()) (c start) (n 0))
      (cond ((= c end) (reverse r))
            ((>= n limit) (reverse (cons (substring s c end) r)))
            (else (loop (cons (string (string-ref s c)) r)
                        (+ c 1)
                        (+ n 1)))))))

(define (%string-split s start end delimiter grammar limit)
  (let ((dlen (string-length delimiter)))
    (define (finish r c)
      (let ((rest (substring s c end)))
        (if (and (eq? grammar 'suffix) (string-null? rest))
          (reverse r)
          (reverse (cons rest r)))))
    (define (scan r c n)
      (if (and limit (>= n limit))
        (finish r c)
        (let ((i (string-contains s delimiter c end)))
          (if i
            (let ((fragment (substring s c i)))
              (if (and (= n 0) (eq? grammar 'prefix) (string-null? fragment))
                (scan r (+ i dlen) (+ n 1))
                (scan (cons fragment r)
                      (+ i dlen)
                      (+ n 1))))
            (finish r c)))))
    (scan '() start 0)))
